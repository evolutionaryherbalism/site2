name: Visual Regression Tests

on:
  schedule:
    - cron: '10/15 * * * *'  # Every 15 minutes
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  visual-regression:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore baseline snapshots
        id: cache-baseline
        uses: actions/cache/restore@v4
        with:
          path: tests/visual-regression.spec.js-snapshots
          key: visual-baselines-v1
          restore-keys: visual-baselines-

      - name: Check baseline exists
        run: |
          if [ "${{ steps.cache-baseline.outputs.cache-hit }}" != "true" ]; then
            echo "❌ No baseline cache found. Run 'Update Visual Baselines' workflow first."
            exit 1
          fi
          if [ ! -d "tests/visual-regression.spec.js-snapshots" ] || [ -z "$(ls -A tests/visual-regression.spec.js-snapshots 2>/dev/null)" ]; then
            echo "❌ Baseline cache is empty. Run 'Update Visual Baselines' workflow first."
            exit 1
          fi
          echo "✅ Baseline cache restored successfully"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps chromium

      - name: Run visual regression tests
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
        run: npm test
        continue-on-error: true
        id: test

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 30

      - name: Send webhook notification on failure
        if: steps.test.outcome == 'failure' && vars.WEBHOOK_URL != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          WEBHOOK_URL: ${{ vars.WEBHOOK_URL }}
        run: |
          cat > notify.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  if (result.status === 'failed') {
                    const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                    const name = match ? match[1] : spec.title;
                    const url = sitesMap.get(name) || 'unknown';

                    const payload = {
                      status: 'failed',
                      name: name,
                      url: url,
                      report_url: reportUrl
                    };

                    fetch(webhook, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(payload)
                    }).catch(err => console.error('Webhook failed:', err));
                  }
                });
              });
            });
          });
          EOF
          node notify.js

      - name: Send always webhook notification
        if: always() && vars.WEBHOOK_URL_ALWAYS != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          WEBHOOK_URL: ${{ vars.WEBHOOK_URL_ALWAYS }}
          TEST_STATUS: ${{ steps.test.outcome }}
        run: |
          cat > notify-always.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
          const testStatus = process.env.TEST_STATUS;

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                  const name = match ? match[1] : spec.title;
                  const url = sitesMap.get(name) || 'unknown';

                  const payload = {
                    status: result.status === 'passed' ? 'success' : 'failed',
                    name: name,
                    url: url,
                    report_url: reportUrl
                  };

                  fetch(webhook, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                  }).catch(err => console.error('Webhook failed:', err));
                });
              });
            });
          });
          EOF
          node notify-always.js

      - name: Fail job if tests failed
        if: steps.test.outcome == 'failure'
        run: exit 1
