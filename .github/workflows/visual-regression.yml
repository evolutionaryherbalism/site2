name: Visual Regression Tests

on:
  schedule:
    - cron: '10/15 * * * *'  # Every 15 minutes
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  visual-regression:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore baseline snapshots
        id: cache-baseline
        uses: actions/cache/restore@v4
        with:
          path: tests/visual-regression.spec.js-snapshots
          key: visual-baselines-v1
          restore-keys: visual-baselines-

      - name: Check baseline exists
        id: baseline-check
        run: |
          if [ "${{ steps.cache-baseline.outputs.cache-hit }}" != "true" ]; then
            echo "❌ No baseline cache found. Run 'Update Visual Baselines' workflow first."
            echo "baseline_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ ! -d "tests/visual-regression.spec.js-snapshots" ] || [ -z "$(ls -A tests/visual-regression.spec.js-snapshots 2>/dev/null)" ]; then
            echo "❌ Baseline cache is empty. Run 'Update Visual Baselines' workflow first."
            echo "baseline_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "✅ Baseline cache restored successfully"
          echo "baseline_exists=true" >> $GITHUB_OUTPUT

      - name: Notify baseline missing
        if: steps.baseline-check.outputs.baseline_exists == 'false' && secrets.WEBHOOK_URL != ''
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"status\":\"failed\",\"name\":\"baseline-check\",\"url\":\"https://github.com/${{ github.repository }}\",\"report_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}"

      - name: Exit if baseline missing
        if: steps.baseline-check.outputs.baseline_exists == 'false'
        run: |
          echo "::error::No baseline found. Run 'Update Visual Baselines' workflow first."
          exit 1

      - name: Setup Node.js
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        run: npm ci

      - name: Cache Playwright browsers
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}

      - name: Install Playwright browsers
        if: steps.baseline-check.outputs.baseline_exists == 'true' && steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps chromium

      - name: Run visual regression tests
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
        run: npm test
        continue-on-error: true
        id: test

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 30

      - name: Upload screenshots to R2
        if: always() && vars.R2_BUCKET_NAME != ''
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: https://${{ vars.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          BUCKET: ${{ vars.R2_BUCKET_NAME }}
          RUN_ID: ${{ github.run_id }}
        run: |
          # Find all screenshots (current, diff, actual)
          TIMESTAMP=$(date +%s)
          find test-results -name "*-current.png" -o -name "*-diff.png" -o -name "*-actual.png" | while read file; do
            filename=$(basename "$file")

            # Extract site name from filename (e.g., "elh-1-current.png" -> "elh-1")
            sitename=$(echo "$filename" | sed 's/-current\.png$//' | sed 's/-diff\.png$//' | sed 's/-actual\.png$//')

            # Determine file type and construct new filename with timestamp
            if [[ "$filename" == *"-current.png" ]]; then
              newfilename="${sitename}-${TIMESTAMP}.png"
            elif [[ "$filename" == *"-diff.png" ]]; then
              newfilename="${sitename}-diff-${TIMESTAMP}.png"
            elif [[ "$filename" == *"-actual.png" ]]; then
              newfilename="${sitename}-actual-${TIMESTAMP}.png"
            fi

            # Upload with clean path: run_id/site-name/site-name-timestamp.png
            s3_path="${RUN_ID}/${sitename}/${newfilename}"
            aws s3 cp "$file" "s3://${BUCKET}/${s3_path}" --endpoint-url "$AWS_ENDPOINT_URL"

            echo "Uploaded: ${s3_path}"
          done

      - name: Send webhook notification on failure
        if: steps.test.outcome == 'failure' && secrets.WEBHOOK_URL != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL }}
          RUN_ID: ${{ github.run_id }}
        run: |
          cat > notify.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const path = require('path');
          const { execSync } = require('child_process');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
          const r2PublicUrl = process.env.R2_PUBLIC_URL;
          const runId = process.env.RUN_ID;

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          // Find screenshot for a test
          function findScreenshot(testName) {
            if (!r2PublicUrl) return { screenshot_url: null, baseline_url: null };

            let screenshotUrl = null;
            let timestamp = null;
            try {
              // Priority: diff (failed) > actual (failed) > current (always exists)
              const diffPath = execSync(`find test-results -type f \\( -name "${testName}-diff.png" -o -name "${testName}-*-diff.png" \\) | head -1`).toString().trim();
              if (diffPath) {
                timestamp = execSync('date +%s').toString().trim();
                screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-diff-${timestamp}.png`;
              } else {
                const actualPath = execSync(`find test-results -type f \\( -name "${testName}-actual.png" -o -name "${testName}-*-actual.png" \\) | head -1`).toString().trim();
                if (actualPath) {
                  timestamp = execSync('date +%s').toString().trim();
                  screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-actual-${timestamp}.png`;
                } else {
                  const currentPath = execSync(`find test-results -type f \\( -name "${testName}-current.png" -o -name "${testName}-*-current.png" \\) | head -1`).toString().trim();
                  if (currentPath) {
                    timestamp = execSync('date +%s').toString().trim();
                    screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-${timestamp}.png`;
                  }
                }
              }
            } catch (e) {}

            const baselineUrl = r2PublicUrl ? `${r2PublicUrl}/baselines/${testName}.png` : null;
            return { screenshot_url: screenshotUrl, baseline_url: baselineUrl };
          }

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  if (result.status === 'failed') {
                    const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                    const name = match ? match[1] : spec.title;
                    const url = sitesMap.get(name) || 'unknown';
                    const { screenshot_url, baseline_url } = findScreenshot(name);

                    const payload = {
                      status: 'failed',
                      name: name,
                      url: url,
                      report_url: reportUrl,
                      screenshot_url: screenshot_url,
                      baseline_url: baseline_url
                    };

                    fetch(webhook, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(payload)
                    }).catch(err => console.error('Webhook failed:', err));
                  }
                });
              });
            });
          });
          EOF
          node notify.js

      - name: Send always webhook notification
        if: always() && secrets.WEBHOOK_URL_ALWAYS != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL_ALWAYS }}
          TEST_STATUS: ${{ steps.test.outcome }}
          R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL }}
          RUN_ID: ${{ github.run_id }}
        run: |
          cat > notify-always.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const path = require('path');
          const { execSync } = require('child_process');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
          const testStatus = process.env.TEST_STATUS;
          const r2PublicUrl = process.env.R2_PUBLIC_URL;
          const runId = process.env.RUN_ID;

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          function findScreenshot(testName) {
            if (!r2PublicUrl) return { screenshot_url: null, baseline_url: null };

            let screenshotUrl = null;
            let timestamp = null;
            try {
              // Priority: diff (failed) > actual (failed) > current (always exists)
              const diffPath = execSync(`find test-results -type f \\( -name "${testName}-diff.png" -o -name "${testName}-*-diff.png" \\) | head -1`).toString().trim();
              if (diffPath) {
                timestamp = execSync('date +%s').toString().trim();
                screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-diff-${timestamp}.png`;
              } else {
                const actualPath = execSync(`find test-results -type f \\( -name "${testName}-actual.png" -o -name "${testName}-*-actual.png" \\) | head -1`).toString().trim();
                if (actualPath) {
                  timestamp = execSync('date +%s').toString().trim();
                  screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-actual-${timestamp}.png`;
                } else {
                  const currentPath = execSync(`find test-results -type f \\( -name "${testName}-current.png" -o -name "${testName}-*-current.png" \\) | head -1`).toString().trim();
                  if (currentPath) {
                    timestamp = execSync('date +%s').toString().trim();
                    screenshotUrl = `${r2PublicUrl}/${runId}/${testName}/${testName}-${timestamp}.png`;
                  }
                }
              }
            } catch (e) {}

            const baselineUrl = r2PublicUrl ? `${r2PublicUrl}/baselines/${testName}.png` : null;
            return { screenshot_url: screenshotUrl, baseline_url: baselineUrl };
          }

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                  const name = match ? match[1] : spec.title;
                  const url = sitesMap.get(name) || 'unknown';
                  const { screenshot_url, baseline_url } = findScreenshot(name);

                  const payload = {
                    status: result.status === 'passed' ? 'success' : 'failed',
                    name: name,
                    url: url,
                    report_url: reportUrl,
                    screenshot_url: screenshot_url,
                    baseline_url: baseline_url
                  };

                  fetch(webhook, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                  }).catch(err => console.error('Webhook failed:', err));
                });
              });
            });
          });
          EOF
          node notify-always.js

      - name: Fail job if tests failed
        if: steps.test.outcome == 'failure'
        run: exit 1
