name: Visual Regression Tests

on:
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  visual-regression:
    runs-on: ubuntu-latest
    env:
      WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
      WEBHOOK_URL_ALWAYS: ${{ secrets.WEBHOOK_URL_ALWAYS }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore baseline snapshots
        id: cache-baseline
        uses: actions/cache/restore@v4
        with:
          path: tests/visual-regression.spec.js-snapshots
          key: visual-baselines-v1
          restore-keys: visual-baselines-

      - name: Check baseline exists
        id: baseline-check
        run: |
          if [ "${{ steps.cache-baseline.outputs.cache-hit }}" != "true" ]; then
            echo "❌ No baseline cache found. Run 'Update Visual Baselines' workflow first."
            echo "baseline_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ ! -d "tests/visual-regression.spec.js-snapshots" ] || [ -z "$(ls -A tests/visual-regression.spec.js-snapshots 2>/dev/null)" ]; then
            echo "❌ Baseline cache is empty. Run 'Update Visual Baselines' workflow first."
            echo "baseline_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "✅ Baseline cache restored successfully"
          echo "baseline_exists=true" >> $GITHUB_OUTPUT

      - name: Notify baseline missing
        if: steps.baseline-check.outputs.baseline_exists == 'false' && env.WEBHOOK_URL != ''
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"status\":\"failed\",\"name\":\"baseline-check\",\"url\":\"https://github.com/${{ github.repository }}\",\"report_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}"

      - name: Exit if baseline missing
        if: steps.baseline-check.outputs.baseline_exists == 'false'
        run: |
          echo "::error::No baseline found. Run 'Update Visual Baselines' workflow first."
          exit 1

      - name: Setup Node.js
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        run: npm ci

      - name: Cache Playwright browsers
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}

      - name: Install Playwright browsers
        if: steps.baseline-check.outputs.baseline_exists == 'true' && steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps chromium

      - name: Run visual regression tests
        if: steps.baseline-check.outputs.baseline_exists == 'true'
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
        run: npm test
        continue-on-error: true
        id: test

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 30

      - name: Upload screenshots to R2
        if: always() && vars.R2_BUCKET_NAME != ''
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: https://${{ vars.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          BUCKET: ${{ vars.R2_BUCKET_NAME }}
          RUN_ID: ${{ github.run_id }}
        run: |
          # Find all screenshots (current, diff, actual)
          TIMESTAMP=$(date +%s)
          echo "{}" > r2-paths.json
          find test-results -name "*-current.png" -o -name "*-diff.png" -o -name "*-actual.png" | while read file; do
            filename=$(basename "$file")

            # Extract site name from filename (e.g., "elh-1-current.png" -> "elh-1")
            sitename=$(echo "$filename" | sed 's/-current\.png$//' | sed 's/-diff\.png$//' | sed 's/-actual\.png$//')

            # Determine file type and construct new filename with timestamp
            if [[ "$filename" == *"-current.png" ]]; then
              newfilename="${sitename}-${TIMESTAMP}.png"
              filetype="current"
            elif [[ "$filename" == *"-diff.png" ]]; then
              newfilename="${sitename}-diff-${TIMESTAMP}.png"
              filetype="diff"
            elif [[ "$filename" == *"-actual.png" ]]; then
              newfilename="${sitename}-actual-${TIMESTAMP}.png"
              filetype="actual"
            fi

            # Upload with clean path: run_id/site-name/site-name-timestamp.png
            s3_path="${RUN_ID}/${sitename}/${newfilename}"
            aws s3 cp "$file" "s3://${BUCKET}/${s3_path}" --endpoint-url "$AWS_ENDPOINT_URL"

            # Store mapping: sitename.type -> full R2 URL
            full_url="${R2_PUBLIC_URL}/${s3_path}"
            echo "Uploaded: ${full_url}"

            # Append to JSON mapping (using jq if available, else simple append)
            if command -v jq &> /dev/null; then
              jq --arg site "$sitename" --arg type "$filetype" --arg url "$full_url" \
                '.[$site + "-" + $type] = $url' r2-paths.json > r2-paths-tmp.json && mv r2-paths-tmp.json r2-paths.json
            else
              # Fallback: write as simple key=value
              echo "${sitename}-${filetype}=${full_url}" >> r2-paths.txt
            fi
          done

          # Also store baseline URLs
          if [ -n "${R2_PUBLIC_URL}" ]; then
            if command -v jq &> /dev/null; then
              find test-results -name "*.png" -type f | while read file; do
                filename=$(basename "$file")
                sitename=$(echo "$filename" | sed 's/-current\.png$//' | sed 's/-diff\.png$//' | sed 's/-actual\.png$//')
                baseline_url="${R2_PUBLIC_URL}/baselines/${sitename}.png"
                jq --arg site "$sitename" --arg url "$baseline_url" \
                  '.[$site + "-baseline"] = $url' r2-paths.json > r2-paths-tmp.json && mv r2-paths-tmp.json r2-paths.json
              done
            fi
          fi

      - name: Send webhook notification on failure
        if: steps.test.outcome == 'failure' && env.WEBHOOK_URL != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL }}
          RUN_ID: ${{ github.run_id }}
        run: |
          cat > notify.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

          // Load R2 paths mapping
          let r2Paths = {};
          if (fs.existsSync('r2-paths.json')) {
            r2Paths = JSON.parse(fs.readFileSync('r2-paths.json', 'utf8'));
          }

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  if (result.status === 'failed') {
                    const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                    const name = match ? match[1] : spec.title;
                    const url = sitesMap.get(name) || 'unknown';

                    // Get URLs from stored R2 paths
                    const screenshotUrl = r2Paths[`${name}-diff`] || r2Paths[`${name}-actual`] || r2Paths[`${name}-current`] || null;
                    const baselineUrl = r2Paths[`${name}-baseline`] || null;

                    // Format as Slack blocks
                    const blocks = [
                      {
                        type: "section",
                        text: {
                          type: "mrkdwn",
                          text: `*❌ Visual Regression Failed: ${name}*\n<${url}|View Page> • <${reportUrl}|View Report>`
                        }
                      }
                    ];

                    if (baselineUrl) {
                      blocks.push({
                        type: "image",
                        image_url: baselineUrl,
                        alt_text: "Baseline screenshot",
                        title: { type: "plain_text", text: "Baseline" }
                      });
                    }

                    if (screenshotUrl) {
                      blocks.push({
                        type: "image",
                        image_url: screenshotUrl,
                        alt_text: "Current screenshot with diff",
                        title: { type: "plain_text", text: "Current (with diff)" }
                      });
                    }

                    const payload = { blocks };

                    fetch(webhook, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(payload)
                    }).catch(err => console.error('Webhook failed:', err));
                  }
                });
              });
            });
          });
          EOF
          node notify.js

      - name: Send always webhook notification
        if: always() && env.WEBHOOK_URL_ALWAYS != ''
        env:
          URLS_CONFIG: ${{ vars.URLS_CONFIG }}
          TEST_STATUS: ${{ steps.test.outcome }}
          R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL }}
          RUN_ID: ${{ github.run_id }}
        run: |
          cat > notify-always.js << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');

          if (!fs.existsSync('test-results/results.json')) process.exit(0);

          const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));
          const webhook = process.env.WEBHOOK_URL_ALWAYS;
          const reportUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

          // Load R2 paths mapping
          let r2Paths = {};
          if (fs.existsSync('r2-paths.json')) {
            r2Paths = JSON.parse(fs.readFileSync('r2-paths.json', 'utf8'));
          }

          const config = process.env.URLS_CONFIG
            ? yaml.load(process.env.URLS_CONFIG)
            : yaml.load(fs.readFileSync('urls.yml', 'utf8'));

          const sitesMap = new Map(config.sites.map(s => [s.name, s.url]));

          results.suites.forEach(suite => {
            suite.specs.forEach(spec => {
              spec.tests.forEach(test => {
                test.results.forEach(result => {
                  const match = spec.title.match(/^(.+?) \((.+?)\)$/);
                  const name = match ? match[1] : spec.title;
                  const url = sitesMap.get(name) || 'unknown';
                  const status = result.status === 'passed' ? 'success' : 'failed';

                  // Get URLs from stored R2 paths
                  const screenshotUrl = r2Paths[`${name}-diff`] || r2Paths[`${name}-actual`] || r2Paths[`${name}-current`] || null;
                  const baselineUrl = r2Paths[`${name}-baseline`] || null;

                  // Format as Slack blocks
                  const emoji = status === 'success' ? '✅' : '❌';
                  const blocks = [
                    {
                      type: "section",
                      text: {
                        type: "mrkdwn",
                        text: `*${emoji} Visual Regression ${status === 'success' ? 'Passed' : 'Failed'}: ${name}*\n<${url}|View Page> • <${reportUrl}|View Report>`
                      }
                    }
                  ];

                  if (baselineUrl) {
                    blocks.push({
                      type: "image",
                      image_url: baselineUrl,
                      alt_text: "Baseline screenshot",
                      title: { type: "plain_text", text: "Baseline" }
                    });
                  }

                  if (screenshotUrl) {
                    const imageTitle = status === 'success' ? 'Current' : 'Current (with diff)';
                    blocks.push({
                      type: "image",
                      image_url: screenshotUrl,
                      alt_text: imageTitle,
                      title: { type: "plain_text", text: imageTitle }
                    });
                  }

                  const payload = { blocks };

                  fetch(webhook, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                  }).catch(err => console.error('Webhook failed:', err));
                });
              });
            });
          });
          EOF
          node notify-always.js

      - name: Fail job if tests failed
        if: steps.test.outcome == 'failure'
        run: exit 1
